<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Article page</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 2rem; }
    main { max-width: 820px; margin: 0 auto; }
    button { padding: .5rem .9rem; border-radius: .4rem; border: 1px solid currentColor; background: transparent; cursor: pointer; }
    code { padding: .1rem .3rem; border-radius: .3rem; background: #f3f3f3; }
    .note { opacity: .8; font-size: .9rem; margin-top:.5rem; }
  </style>
</head>
<body>
  <main>
    <h1 id="title">Article page (waiting)</h1>
    <p><a href="./index.html">Home</a></p>
    <p>Status: <code id="status">not hacked</code></p>

    <p>
      <button id="enableReal">Enable Back (real navigation)</button>
      <button id="enableFake">Enable Back (pushState only)</button>
      <button id="backBtn">← Back</button>
    </p>

    <p class="note">Real navigation adds <code>?entry=1</code> to the URL which creates a genuine history entry (better for webviews). Use the first button if the in-app browser ignores pushState.</p>
  </main>

  <script>
    (function () {
      const BASE = location.pathname.replace(/\/[^\/]*$/, '/');
      const HOME = BASE + 'index.html';
      const title = document.getElementById('title');
      const statusEl = document.getElementById('status');
      const enableReal = document.getElementById('enableReal');
      const enableFake = document.getElementById('enableFake');
      const backBtn = document.getElementById('backBtn');

      let hacked = false;

      function setStatus(text) {
        console.log('[Article]', text);
        if (statusEl) statusEl.textContent = text;
      }

      function hackHistory(reason) {
        if (hacked) return true;
        try {
          // We still do replace+push to add an in-page guard for fast back handling.
          history.replaceState({ trap: true, reason, t: Date.now() }, '', location.href);
          history.pushState({ trap: true, guard: true, reason, t: Date.now() }, '', location.href);
          hacked = true;
          setStatus('history hacked (' + reason + ')');
          if (title) title.textContent = 'Article page (history hacked)';
          return true;
        } catch (e) {
          console.warn('[Article] history hack failed:', e);
          if (title) title.textContent = 'Article page (failed to hack)';
          setStatus('failed to hack: ' + (e && e.message ? e.message : e));
          return false;
        }
      }

      // Popstate handler ready immediately
      window.addEventListener('popstate', () => {
        console.log('[Article] popstate → redirecting to', HOME);
        location.replace(HOME);
      });

      // Detect if this visit already includes the real-nav param
      const url = new URL(location.href);
      const hasEntryParam = url.searchParams.get('entry') === '1';

      if (hasEntryParam) {
        console.log('[Article] arrived with ?entry=1 — doing local hack to create guard');
        // When arriving via real navigation, install local guard quickly
        // without an extra redirect loop:
        // small timeout to let webview settle
        setTimeout(() => hackHistory('arrived-real-nav'), 50);
        setStatus('arrived via real navigation');
      } else {
        setStatus('waiting for user trigger');
      }

      // Enable Real: perform an actual navigation to same URL + ?entry=1
      enableReal.addEventListener('click', () => {
        if (hasEntryParam) {
          setStatus('already real-navigated');
          hackHistory('already-real');
          return;
        }
        console.log('[Article] enableReal clicked — navigating to URL with ?entry=1 (real nav)');
        // Construct new URL preserving hash
        const target = new URL(location.href);
        target.searchParams.set('entry', '1');
        // Real navigation (user gesture) — creates true history entry in webview
        location.href = target.toString();
      });

      // Enable Fake: do the in-page replace+push (may be ignored by some webviews)
      enableFake.addEventListener('click', () => {
        console.log('[Article] enableFake clicked — trying in-page hack');
        const ok = hackHistory('click-fake');
        if (!ok) {
          setStatus('fake hack failed; try real nav');
        }
      });

      // Back button: prefer history.back(); if not hacked, fall back to direct navigation
      backBtn.addEventListener('click', () => {
        console.log('[Article] Back button clicked — hacked?', hacked);
        if (!hacked) {
          setStatus('not hacked yet — attempting quick hack then back');
          const ok = hackHistory('click-backbtn');
          if (!ok) {
            console.log('[Article] quick hack failed — navigating to HOME directly');
            location.replace(HOME);
            return;
          }
        }
        history.back();
      });

      // ---- Extra hacky workarounds (not enabled by default) ----
      // 1) Fragment trick: use location.hash change to create a real entry (works almost everywhere)
      function fragmentTrick() {
        const h = '#__entry_' + Date.now();
        console.log('[Article] fragmentTrick creating hash', h);
        location.hash = h; // creates a history entry
        // Later, when user hits back, you'll be on previous URL (hash removed)
      }

      // 2) Open-and-close window trick (will be blocked in many in-app browsers)
      function popupTrick() {
        try {
          const w = window.open(location.pathname + '?entry=tmp', '_blank');
          if (w) {
            console.log('[Article] popup opened — closing to create history entry');
            setTimeout(() => { try { w.close(); } catch(e){console.warn(e);} }, 300);
          } else {
            console.warn('[Article] popup blocked');
          }
        } catch (e) {
          console.warn('[Article] popupTrick failed', e);
        }
      }

      // 3) Meta refresh redirect (serverless, but navigates away-and-back if used with intermediate page)
      // Not implemented here but described in README.

      // expose for debugging via console
      window._demo = { hackHistory, fragmentTrick, popupTrick };

    })();
  </script>
</body>
</html>
